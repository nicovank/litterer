#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <exception>
#include <fstream>
#include <ios>
#include <iostream>
#include <vector>

#include <argparse/argparse.hpp>

#include "shared.hpp"

bool closeEnough(std::uint64_t a, std::uint64_t b, std::uint64_t distance) {
    return (std::max(a, b) - std::min(a, b)) <= distance;
}

int main(int argc, char** argv) {
    auto program = argparse::ArgumentParser("benchmark_iterator", "",
                                            argparse::default_arguments::help);
    program.add_argument("-i", "--input")
        .help("input file, generated by the logger tool")
        .default_value("events.bin")
        .metavar("FILE");
    program.add_argument("--moving-average")
        .help("with which value to smooth the output (default: 1024)")
        .default_value(std::uint64_t(1024))
        .metavar("N")
        .scan<'u', std::uint64_t>();
    program.add_argument("--epsilon")
        .help(
            "what distance to consider two pointers close enough (default: 8)")
        .default_value(std::uint64_t(8))
        .metavar("N")
        .scan<'u', std::uint64_t>();

    try {
        program.parse_args(argc, argv);
    } catch (const std::exception& err) {
        std::cerr << err.what() << std::endl;
        std::cerr << program;
        std::exit(EXIT_FAILURE);
    }

    const auto input = program.get<std::string>("--input");
    const auto bufferSize = program.get<std::uint64_t>("--moving-average");
    const auto epsilon = program.get<std::uint64_t>("--epsilon");

    std::ifstream input_file(input, std::ios::binary);
    if (!input_file) {
        std::cerr << "Failed to open " << input << std::endl;
        std::exit(EXIT_FAILURE);
    }

    std::vector<bool> buffer(bufferSize);
    std::size_t index = 0;
    std::uint64_t last = 0;
    std::uint64_t count = 0; // Number of 'true' values in the buffer.

    // Initial fill.
    Event event;
    for (;;) {
        if (!input_file.read(reinterpret_cast<char*>(&event), sizeof(event))) {
            std::cerr << "Not enough data in input file." << std::endl;
            std::exit(EXIT_FAILURE);
        }

        if (event.type == EventType::Allocation
            || event.type == EventType::Reallocation) {
            buffer[index] = closeEnough(last, event.result, epsilon);
            count += static_cast<std::uint64_t>(buffer[index]);
            last = event.result + event.size;
            ++index;
        }

        if (index == bufferSize) {
            index = 0;
            break;
        }
    }

    while (input_file.read(reinterpret_cast<char*>(&event), sizeof(event))) {
        if (event.type == EventType::Allocation
            || event.type == EventType::Reallocation) {
            count -= static_cast<std::uint64_t>(buffer[index]);
            buffer[index] = closeEnough(last, event.result, epsilon);
            count += static_cast<std::uint64_t>(buffer[index]);

            last = event.result + event.size;

            ++index;
            index %= bufferSize;

            std::cout << static_cast<double>(count)
                             / static_cast<double>(bufferSize)
                      << std::endl;
        }
    }
}
